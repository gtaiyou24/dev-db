# 検索

## クエリの操作

| APIエンドポイント | クエリの範囲 |
|:----------------|:-----------|
| `http://<サーバ名>:9200/<インデックス名>/_search` | インデックスを対象に検索 |
| `http://<サーバ名>:9200/<インデックス名>/<タイプ名>/_search` | インデックス内のタイプを対象に検索 |
| `http://<サーバ名>:9200/<インデックス名1>,<インデックス名2>/_search` | <インデックス名1>および<インデックス名2>を対象に検索 |
| `http://<サーバ名>:9200/my_index*/_search` | <my_index>で始まるインデックス名すべてを対象に検索 |
| `http://<サーバ名>:9200/_search` | クラスタ内の全てのインデックスを対象に検索 |

## クエリDSL (Query DSL)

**クエリDSLを用いた検索の実行方法**
```bash
curl -H "Content-Type: application/json" -XGET http://<サーバ名>:9200/<インデックス名>/_search -d '<Query DSL>'
```

**クエリDSLシンタックス**
```json
{
    "query": {<検索クエリ内容>},
    "from": 0,
    "size": 10,
    "sort": [<検索結果のソート指定>],
    "_source": [<検索結果に含めたいフィールド>]
}
```
検索パラメータ

| パラメータ | デフォルト | 説明 |
|:----------|:---------|:-----|
| `query` |  | 検索条件。クエリDSLと呼ばれるDSLが複数ある |
| `from` | 0 | 検索結果に含まれるデータの開始位置 |
| `size` | 10 | 検索結果に含まれるデータのサイズ |
| `sort` | `_score` | ソートの指定. `asc`/`desc`で順序を指定 |
| `_source` |  | 検索結果に含むフィールドを指定 |
| `aggs` |  | Aggregation. 検索結果に含まれるデータに対して、様々な集計処理を実施する. |


## クエリのレスポンス
クエリを実行したときのレスポンスの例

```json
{
    "took": <検索にかかった時間(ms)>,
    "timed_out": false,
    "_shards": {...},
    "hits": {
        "total": <ヒット件数>,
        "hits": [
            {
                "_index": "<インデックス名>",
                "_type": "<タイプ名>",
                "_id": "<ドキュメントID>",
                "_score" : <検索にヒットしたドキュメントがどの程度クエリ条件に当てはまるかを表す関連度>,
                "_source": {<検索にヒットしたドキュメント>},
                "_index": "<インデックス名>",
                "_type": "<タイプ名>",
                "_id": "<ドキュメントID>",
                "_score" : <検索にヒットしたドキュメントがどの程度クエリ条件に当てはまるかを表す関連度>,
                "_source": {<検索にヒットしたドキュメント>},
            }
        ]
    }
}
```
レスポンスの項目

| 項目 | 説明 |
|:----:|:----:|
| `hits` | 検索結果の情報 |
| `hits.total` | 検索条件にヒットした件数 |
| `hits.hits` | 検索にヒットしたドキュメントの配列(検索結果のfrom/sizeで指定した場所のドキュメント) |

## 検索クエリ
### 全文検索クエリ
text型のフィールド型を対象に検索するクエリ

> **match_allクエリ**
>
> - 検索条件を指定しなくても必ず全件返す
> - ヒットした関連度を示す`_score`の値も全件に1.0の最大値が付与される
> - `match_all`クエリは主に格納されたドキュメントの確認などに使う
```json
{
    "query": {
        "match_all": {}
    }
}
```

> **matchクエリ**
>
> - 典型的な全文検索の用途で使うクエリ
> - `match`句の中にフィールド名および検索キーワードを指定
```json
// 検索キーワードを複数指定する方法
{
    "query": {
        "match": {
            "フィールド名": "キーワード1 キーワード2" // OR条件
        }
    }
}

// 検索条件のオペレータ("and"または"or")を指定する方法
{
    "query": {
        "match": {
            "フィールド名": "キーワード1 キーワード2", // AND条件
            "operator": "and"
        }
    }
}

// 細かな検索条件を指定する方法
{
    "query": {
        "match": {
            "フィールド名": "キーワード1 キーワード2 キーワード3 キーワード4",  // 最低2個以上のキーワードが含まれていること
            "minimum_should_match": 2  // 指定方法は数値または、割合(%)のいずれかが可能. 2の代わりに50%と指定することが可
        }
    }
}
```

> **match_phraseクエリ**
>
> - 複数キーワードを指定した際に、指定された語順のドキュメントのみを検索する
```json
{
    "query": {
        "match_phrase": {
            "<text型のフィールド名>": "キーワード1 キーワード2"  // 指定されたキーワードはその順序で並んでいることも条件に含まれる
        }
    }
}
```

> **query_string**
>
> - 検索条件部分にLuceneシンタックスでの検索式を直接記載できる
> - Luceneの細かい検索クエリが必要な場合にはquery_stringクエリを使う
```json
{
    "query": {
        "default_field": "フィールド名",
        "query": "<Luceneシンタックスでの検索式>"
    }
}
```


### Termベースクエリ
Termベースクエリとは、指定した検索キーワードに完全一致したフィールドを探すときに使うクエリ種別です。keyword型のフィールドを検索するために使うクエリ

> **Termクエリ**
>
> - term句の中にフィールド名および検索キーワードを指定して**完全一致検索**を行う
> - あくまで完全一致なので、大文字小文字の種別も含めて、格納した語句とまったく同じキーワードを指定しないと検索にヒットしない
```json
{
    "query": {
        "term": {
            "<keyword型のフィールド名>": "キーワード"
        }
    }
}
```

> **Termsクエリ**
>
> - Termクエリと同様に完全一致検索を行うクエリだが、検索キーワードを複数指定できる
```json
{
    "query": {
        "terms": {
            "<keyword型のフィールド名>": ["キーワード1", "キーワード2"]  // 複数指定したキーワードのうちどれか１つでも一致すれば検索にヒットする
        }
    }
}
```

> **Rangeクエリ**
>
> - 主に数値型や日付型のフィールドを対象として、値の範囲検索を行うためのクエリ
```json
// 数値型の"stock_price"というフィールドを対象に、15.00以上25.00以下の範囲検索を行なっている例
{
    "query": {
        "range": {
            "stock_price": {
                "gte": "15.0",
                "lte": "25.0"
            }
        }
    }
}

// 日付型の例
{
    "query": {
        "range": {
            "birthday": {
                "gte": "2010-04-02",
                "lte": "2011-04-01"
            }
        }
    }
}

// 日付計算式の利用例. 現在から1週間以内に製造された商品を検索する例
{
    "query": {
        "range": {
            "manufactured_date": "now-1w"
        }
    }
}
```

Rangeクエリで使える範囲指定のオペレータ

| オペレータ名 | 意味 |
|:-----------|:-----|
| `gte` | ~以上 |
| `lte` | ~以下 |
| `gt` | ~より大きい |
| `lt` | ~より小さい |

Rangeクエリの日付計算式で利用可能な表現

| 記号 | 意味 |
|:----|:-----|
| `y` | 年 |
| `M` | 月 |
| `w` | 週 |
| `d` | 日 |
| `h`,`H` | 時間 |
| `m` | 分 |
| `s` | 秒 |


### 複合クエリ - Boolクエリ
Boolクエリは、上記の基本的な検索クエリを複数組み合わせて、複合クエリを構成するための記法です。

**BoolクエリのクエリDSLシンタックス**
```json
{
    "query": {
        "bool": {
            "must": [<基本クエリ>, <基本クエリ>,...],
            "should": [<基本クエリ>, <基本クエリ>,...],
            "must_not": [<基本クエリ>, <基本クエリ>,...],
            "filter": [<基本クエリ>, <基本クエリ>,...]
        }
    }
}
```

> **mustクエリ**(AND条件)
>
> - must句の中には必ず含まれているべきクエリ条件を記載する
> - must句の中に複数の基本クエリを指定した場合は、そのすべての条件が満たされる必要があります(AND条件)


> **shouldクエリ**(OR条件)
>
> - should句の中に複数の基本クエリを指定した場合、いずれかのクエリ条件を満たせばドキュメントがヒットする(OR条件)


> **minimum_should_matchクエリ**
>


> **must_notクエリ**(NOT条件)
>
> - must_not句の中に指定した、基本クエリに当てはまるドキュメントは、検索結果から除外される(NOT条件)


> **filterクエリ**
>
> - オプションとして使われる句
> - 他4つのクエリについては、検索条件の関連度に応じて、スコアが返されます。filterクエリでは、検索条件にマッチするかしないか(YesかNoか)のみが返されます。

例) 直近1週間以内に格納されたドキュメントであり、かつ、メッセージ内容に"Elasticsearch"という語句を含む検索の例を考える。<br>
このとき、must/should/must_not句では、指定したクエリに各ドキュメントがどの程度マッチしているかを示す条件を記載して、結果としては関連度を表すスコア(`_score`)が返されます。一方、filter句では、条件に指定したクエリに各ドキュメントが当てはまるか、否やが判定され、結果としては当てはまるドキュメントのみが返される。

```json
// filter句で記載した「直近1週間以内」という条件については、いわば、対象外のドキュメントの「足切り」をしているだけであって、
// 検索結果のスコアには影響を与えない点に注意してください
{
    "query": {
        "bool": {
            "must": [
                {"match": {"message": "Elasticsearch"}}
            ],
            "filter": [
                {"range": {"date": {"gte": "now-1w"}}}
            ]
        }
    }
}
```

最後にfilterクエリで知っておくと便利な機能を紹介しておきます。

> filterクエリでは、クエリキャッシュと呼ばれるキャッシュ機構があり、単に検索範囲を限定したい、スコアに関連しなくてもよいクエリであれば、一般にfilterクエリを使うことで性能向上が図れます。<br>
> filterクエリは、検索結果をクエリキャッシュとして各セグメント単位でメモリ上に保持します。したがって、一度検索されたクエリと同じfilterクエリを発行した場合は、このクエリキャッシュが使われるために、非常に高速に検索ができるのです。



